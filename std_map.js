// Generated by CoffeeScript 1.12.7
(function() {
  var Drw1, Jimp, K, Promise, arr, colors, comparePoints, f1, findPointInTraectory, fraction, frun, fs, init, itCount, mod2Pi, needLyap, pi, ranges, rgbToInt, round, run, setColor, setColor2, show, size, step, stepLog, tPi;

  Jimp = require('Jimp');

  fs = require('fs');

  Promise = require('bluebird');

  pi = Math.PI;

  K = 1;

  step = 0.1;

  size = 500;

  ranges = [0.1, 0.3, 0.6];

  stepLog = 0;

  colors = [0xFFFFFFFF, 0xFF0F0FFF, 0x00FF26FF, 0x2408FFFF, 0x000000FF];

  itCount = 100000;

  arr = [];

  init = function() {
    var i, l, ref, results;
    results = [];
    for (i = l = 0, ref = size; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      results.push(arr.push([]));
    }
    return results;
  };

  setColor = function(v) {
    var i, l, ref;
    if (v === void 0 || v === (0/0)) {
      return colors[0];
    }
    for (i = l = 0, ref = ranges.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      if (v < ranges[i]) {
        return colors[i + 1];
      }
    }
    return colors[colors.length - 1];
  };

  setColor2 = function(v) {
    if (v === void 0 || v < tol) {
      return colors[0];
    } else {
      return colors[colors.length - 1];
    }
  };

  show = function(name) {
    return new Promise(function(resolve, reject) {
      var img;
      return img = new Jimp(size, size, function(error, img) {
        var color, i, j, l, m, ref, ref1;
        if (error) {
          reject(error);
        } else {
          resolve(0);
        }
        for (i = l = 0, ref = size; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          for (j = m = 0, ref1 = size; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
            color = needLyap ? setColor(arr[i][j]) : setColor(arr[i][j]);
            img.setPixelColor(color, j, i);
          }
        }
        return img.write("./files/" + name + ".jpg", function(error) {
          if (error) {
            return reject(error);
          } else {
            return resolve(0);
          }
        });
      });
    });
  };

  rgbToInt = function(r, g, b) {
    return (r << 24) + (g << 16) + (b << 8);
  };

  fraction = function(x) {
    return x - Math.trunc(x);
  };

  mod2Pi = function(x) {
    if (x < 0) {
      x += tPi;
    }
    return (fraction(x / tPi)) * tPi;
  };

  round = function(x) {
    return Math.round(x * (size - 1) / tPi);
  };

  comparePoints = function(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  };

  findPointInTraectory = function(point, traectory) {
    var l, len, tp;
    for (l = 0, len = traectory.length; l < len; l++) {
      tp = traectory[l];
      if (comparePoints(tp, point)) {
        return true;
      }
    }
    return false;
  };

  Drw1 = function(x, y) {
    var LLE, dn, dq, ep, epn, eq, eqn, i, l, len, lsum, m, point, ref, results, start, traectory;
    traectory = [];
    ep = 1;
    eq = 0;
    lsum = 0;
    i = 0;
    start = [x, y];
    for (i = l = 0, ref = itCount; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      stepLog++;
      x = mod2Pi(x + K * Math.sin(y));
      y = mod2Pi(y + x);
      if (needLyap) {
        dq = K * Math.cos(y);
        epn = ep + dq * eq;
        eqn = ep + (1 + dq) * eq;
        ep = epn;
        eq = eqn;
        dn = Math.sqrt(ep * ep + eq * eq);
        ep = ep / dn;
        eq = eq / dn;
        lsum += Math.log(dn);
        traectory.push({
          x: x,
          y: y
        });
      } else {
        if (arr[round(x)][round(y)] === void 0) {
          arr[round(x)][round(y)] = 1;
        } else {
          arr[round(x)][round(y)] += 1;
        }
      }
    }
    if (needLyap) {
      LLE = lsum / itCount;
      results = [];
      for (m = 0, len = traectory.length; m < len; m++) {
        point = traectory[m];
        if (arr[round(point.x)][round(point.y)] === void 0) {
          results.push(arr[round(point.x)][round(point.y)] = LLE);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  run = function(t0, max, d) {
    var results;
    arr = [];
    init();
    results = [];
    while (t0 <= max) {
      Drw1(t0, d);
      Drw1(d, t0);
      results.push(t0 += step);
    }
    return results;
  };

  frun = function(t0, max, d) {
    arr = [];
    init();
    return Drw1(0, 3.4);
  };

  module.exports = f1 = function(k, st, sz, c, r, runSettings, name) {
    return new Promise(function(resolve) {
      var runEnd, start;
      K = k;
      step = st;
      size = sz;
      colors = c;
      ranges = r;
      if (!(K > 0) || !(step > 0) || !(size > 0)) {
        return "error";
      }
      start = new Date().getTime();
      run(runSettings.t0, runSettings.max, runSettings.d);
      runEnd = new Date().getTime();
      console.log("run time = " + (runEnd - start));
      return show(name).then(function() {
        var showEnd;
        showEnd = new Date().getTime();
        console.log("show time = " + (showEnd - runEnd));
        console.log("total time = " + (showEnd - start));
        console.log("steps = " + stepLog);
        return resolve(0);
      })["catch"](function(err) {
        return console.log(err);
      });
    });
  };

  tPi = 2 * pi;

  needLyap = true;

  f1(1, 0.1, 1000, colors, ranges, {
    t0: 0,
    max: 2 * pi,
    d: 0
  }, "test32145");

}).call(this);
